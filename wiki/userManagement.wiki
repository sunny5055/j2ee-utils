#summary User management.
=user-management=

==Getting started==

There are several parts in the `user-management` configuration :
<ol> 
	<li>You need to set up a proper connection to your database, using Hibernate : </li>
		<ul>
			<li>The first bean you must declare is a `ComboPooledDataSource` object type. It handles a connection pool to your database.</li>
			<li>The second bean is a `LocalSessionFactoryBean` type of bean. It handles a JDBC connection to your database and manage the persisted objects. It reads into a `hibernate.properties` file.</li>
			<li>The third bean is a `HibernateTransactionManager` type of bean. It uses the `sessionFactory` and handles all the database transactions.</li>
			<li>The fourth and fifth beans are `strongEncryptor` and `hibernateStringEncryptor` types of bean. It allows to encrypt and decrypt string properties (like passwords) of the persisted objects. The JCE provider is Bouncy Castle.</li>
		</ul>
	<li>You need to define a configuration using Spring's AOP, in order to manage the Hibernate transactions : </li>
		<ul>
			<li>Fist of all, you must define pointcuts for every of your DAOs and Services classes. All the methods contained in those classes, have to be handled by a transaction.</li>
			<li>You must define a `<tx:advice>` tag for your Services. Every method that begins with `get`, `find`, `exist` or `count` are read-only methods and implies that a transaction as already been opened.</li>
			<li>You must define a `<tx:advice>` tag for your DAOs. Every method that begins with `get`, `find`, `exist` or `count` are read-only methods, but doesn't implies that a transaction as already been opened. Generally, a transaction is opened every time a DAO method is being used.</li>
		 </ul>
</ol>
{{{
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:util="http://www.springframework.org/schema/util"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
		http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd">

	<context:component-scan base-package="com.google" />
	<context:annotation-config />

	<context:property-placeholder location="classpath:spring/database.properties" />

	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
		destroy-method="close">
		<property name="driverClass" value="${jdbc.driverClassName}" />
		<property name="jdbcUrl" value="${jdbc.url}" />
		<property name="user" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
		<property name="acquireIncrement" value="${c3p0.acquire_increment}" />
		<property name="idleConnectionTestPeriod" value="${c3p0.idle_test_period}" />
		<property name="minPoolSize" value="${c3p0.min_size}" />
		<property name="maxPoolSize" value="${c3p0.max_size}" />
		<property name="loginTimeout" value="${c3p0.timeout}" />
		<property name="maxStatements" value="${c3p0.max_statements}" />
	</bean>

	<bean id="sessionFactory"
		class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<property name="hibernateProperties">
			<props>
				<prop key="hibernate.dialect">${hibernate.dialect}</prop>
				<prop key="hibernate.hbm2ddl.auto">${hibernate.hbm2ddl.auto}</prop>
				<prop key="hibernate.show_sql">${hibernate.show_sql}</prop>
				<prop key="hibernate.cache.use_query_cache">${hibernate.cache.use_query_cache}</prop>
				<prop key="hibernate.connection.release_mode">${hibernate.connection.release_mode}</prop>
				<prop key="hibernate.auto_close_session">${hibernate.auto_close_session}</prop>
			</props>
		</property>
		<property name="packagesToScan" value="com.google" />
	</bean>

	<bean id="transactionManager"
		class="org.springframework.orm.hibernate4.HibernateTransactionManager">
		<property name="sessionFactory" ref="sessionFactory" />
		<property name="nestedTransactionAllowed" value="true" />
	</bean>
	
	<!-- Enccrypt JASYPT -->
	<bean id="strongEncryptor"
		class="org.jasypt.encryption.pbe.StandardPBEStringEncryptor">   
	  	<property name="providerName"><value>BC</value></property> 
	   	<property name="algorithm">
        	<value>PBEWITHSHA256AND128BITAES-CBC-BC</value> 
	   	</property>
	   	<property name="password">
   	    	<value>jasypt</value>
	   	</property>
   	</bean>
  
   	<!-- hibernate Encryptor for string -->
	<bean id="hibernateStringEncryptor"
		class="org.jasypt.hibernate4.encryptor.HibernatePBEStringEncryptor">
		<property name="registeredName">
			<value>strongHibernateStringEncryptor</value>
	  	</property>
	  	<property name="encryptor">
			<ref bean="strongEncryptor" />
		</property>
	</bean>

	<aop:config>
		<!-- Pointcut utilisé pour les transactions -->
		<aop:pointcut id="servicePointcut"
			expression="execution(* com.google..*Service*.*(..))" />
		<aop:pointcut id="daoPointcut" expression="execution(* com.google..*Dao*.*(..))" />

		<aop:advisor advice-ref="serviceTxAdvice" pointcut-ref="servicePointcut" />
		<aop:advisor advice-ref="daoTxAdvice" pointcut-ref="daoPointcut" />
	</aop:config>

	<tx:advice id="serviceTxAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="get*" read-only="true" propagation="REQUIRED" />
			<tx:method name="find*" read-only="true" propagation="REQUIRED" />
			<tx:method name="count*" read-only="true" propagation="REQUIRED" />
			<tx:method name="exist*" read-only="true" propagation="REQUIRED" />
			<tx:method name="*" propagation="REQUIRED" />
		</tx:attributes>
	</tx:advice>
	<tx:advice id="daoTxAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<tx:method name="get*" read-only="true" propagation="MANDATORY" />
			<tx:method name="find*" read-only="true" propagation="MANDATORY" />
			<tx:method name="count*" read-only="true" propagation="MANDATORY" />
			<tx:method name="exist*" read-only="true" propagation="MANDATORY" />
			<tx:method name="*" propagation="MANDATORY" />
		</tx:attributes>
	</tx:advice>
</beans>
}}}

After you've finished the Spring configuration, you must now define a `database.properties`, which is used by the `application-context.xml` file.
Here is an example of a `PostgreSQL` connection with `Hibernate` abd `c3po`.

{{{
# Jdbc
jdbc.driverClassName=org.postgresql.Driver
jdbc.maxActive=100
jdbc.maxWait=1000
jdbc.url=jdbc:postgresql://localhost:5432/user-management
jdbc.username=postgres
jdbc.password=postgres

# Hibernate
hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
hibernate.show_sql=false
hibernate.hbm2ddl.auto=update
hibernate.connection.release_mode=auto
hibernate.auto_close_session=true
hibernate.cache.use_query_cache=false

# c3p0
c3p0.acquire_increment=1
c3p0.idle_test_period=100
c3p0.min_size=10
c3p0.max_size=100
c3p0.timeout=100
c3p0.max_statements=0
}}}

Finally, you must define a log4j.xml file that handles all the logging functions.

{{{
<?xml version="1.0" encoding="UTF-8" ?>
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
	<!-- APPENDER -->
	<appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
		<layout class="org.apache.log4j.PatternLayout">
			<param name="ConversionPattern" value="%d{ABSOLUTE} %-5p [%c{3}] %m%n" />
		</layout>
	</appender>

	<logger name="org.hibernate">
		<level value="debug" />
		<appender-ref ref="CONSOLE" />
	</logger>
	<root>
		<level value="debug" />
		<appender-ref ref="CONSOLE" />
	</root>
</log4j:configuration>
}}}

Use the component as follows :

{{{
   public static void main(String[] args) {
    	
        final ApplicationContext context = new ClassPathXmlApplicationContext("spring/application-context.xml");
        final UserService userService = context.getBean(UserService.class);
        final RoleService roleService = context.getBean(RoleService.class);
        final RightService rightService = context.getBean(RightService.class);

        // Instantiates arrays of informations about users 
        String[] firstNames = { "Nicolas", "Jérome", "Robert", "Nathan", "Justine",
        		"Jordan", "Julie", "Sophie", "Hacker" };
        String[] lastNames = { "Dupont", "Meyer", "Durand", "Lefebvre", "Lopez",
        		"Perrin", "Lerroy", "Chevalier", "Hacker" };
        String[] logins = { "n.dupont54", "j.meyer22", "r.durand89" ,"n.lefebvre78", 
        		"j.lopez54", "j.perrin12", "j.lerroy93", "s.chevalier36", "H@ck3r" };
        String[] passwords = { "38Sdsqd", "sflj2", "s234F", "37HDd", "93jdsklqd",
        		"dfj9", "hedo32", "DDKML3","123" };
        String[] mails = { "nico.dupont@gmail.com", "j.meyer@wanadoo.fr", "durand.robert@systemDco.eu", 
        		"nathan@yahoo.fr", "lopez@etu-univnancy2.fr", "jordan_perrin@free.fr", "julie93@hotmail.com",
        		"sophie.chevalier@systemDco.eu", "hello@world.java" };
        
        // Instantiates arrays of informations about roles
        String[] roleCodes = { "ADMINISTRATOR", "MODERATOR", "REDACTOR", "CONTRIBUTOR", "MEMBER", "GUESS" };
        String[] roleDescriptions = { "The administrator of the application", "A special user who moderates the contributions of others users",
        		"An user who publishes articles", "A valuable user because of his contributions", "A simple user", "A guess (default role)" };
        
        // Instantiates arrays of informations about rights
        String[] rightCodes = { "WRITE", "EDIT", "EDIT_ALL", "DELETE", "DELETE_ALL", "READ", "READ_ALL" };
        String[] rightDescriptions = { "Is allowed to write an article", "Is allowed to edit his articles", "Is allowed to edit all articles",
        		"Is allowed to delete his articles", "Is allowed to delete all articles", "Is allowed to read public articles",
        		"Is allowed to read all articles" };
        
        // Create rights
        for (int i = 0 ; i < 7 ; i++) {
        	Right right = new Right();
        	right.setCode(rightCodes[i]);
        	right.setDescription(rightDescriptions[i]);
        	rightService.create(right);
        }
        
        // Create roles and binds them to rights
        for (int i = 0 ; i < 6 ; i++) {
        	Role role = new Role();
        	role.setCode(roleCodes[i]);
        	role.setDescription(roleDescriptions[i]);
        	List<Right> rights = new ArrayList<Right>();
        	if (role.getCode().equals("ADMINISTRATOR")) {
        		rights.addAll(rightService.findAll());
        	} else if (role.getCode().equals("MODERATOR")) {
        		rights.add(rightService.findByRightCode("EDIT"));
        		rights.add(rightService.findByRightCode("EDIT_ALL"));
        		rights.add(rightService.findByRightCode("DELETE"));
        		rights.add(rightService.findByRightCode("DELETE_ALL"));
        		rights.add(rightService.findByRightCode("READ"));
        		rights.add(rightService.findByRightCode("READ_ALL"));
        	} else if (role.getCode().equals("REDACTOR")) {
        		rights.add(rightService.findByRightCode("WRITE"));
        		rights.add(rightService.findByRightCode("EDIT"));
        		rights.add(rightService.findByRightCode("DELETE"));
        		rights.add(rightService.findByRightCode("READ"));
        	} else if (role.getCode().equals("CONTRIBUTOR")) {
        		rights.add(rightService.findByRightCode("READ_ALL"));
        	} else if (role.getCode().equals("MEMBER")) {
        		rights.add(rightService.findByRightCode("READ"));
        	}
        	role.setRights(rights);
        	roleService.create(role);
        }
        
        // Create users and binds them to roles
        for (int i = 0 ; i < 8 ; i++) {
        	User user = new User();
        	user.setFirstName(firstNames[i]);
        	user.setLastName(lastNames[i]);
        	user.setLogin(logins[i]);
        	user.setPassword(passwords[i]);
        	user.setMail(mails[i]);
        	List<Role> roles = new ArrayList<Role>();
        	if (user.getFirstName().equals("Nicolas")) {
        		roles.add(roleService.findByRoleCode("MEMBER"));
        	} else if (user.getFirstName().equals("Jérome")) {
        		roles.add(roleService.findByRoleCode("MEMBER"));
        	} else if (user.getFirstName().equals("Robert")) {
        		roles.add(roleService.findByRoleCode("ADMINISTRATOR"));
        	} else if (user.getFirstName().equals("Nathan")) {
        		roles.add(roleService.findByRoleCode("REDACTOR"));
        	} else if (user.getFirstName().equals("Justine")) {
        		roles.add(roleService.findByRoleCode("REDACTOR"));
        		roles.add(roleService.findByRoleCode("CONTRIBUTOR"));
        	} else if (user.getFirstName().equals("Jordan")) {
        		roles.add(roleService.findByRoleCode("REDACTOR"));
        	} else if (user.getFirstName().equals("Julie")) {
        		roles.add(roleService.findByRoleCode("GUESS"));
        	} else if (user.getFirstName().equals("Sophie")) {
        		roles.add(roleService.findByRoleCode("MODERATOR"));
        	}
        	user.setRoles(roles);
        	userService.create(user);
        }
        
    }
}}}	